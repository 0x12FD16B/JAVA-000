# 学习笔记

> JVM 线程堆栈数据分析

JVM 内部线程主要分为以下几种：

* VM 线程：单例的 VMThread 对象，负责执行 VM 操作
* 定时任务线程：单例的 WatcherThread 对象， 模拟在 VM 中执行定时操作的计时器中断；
* GC 线程：垃圾收集器中，用于支持并行和并发垃圾回收的线程; 
* 编译器线程：将字节码编译为本地机器代码; 
* 信号分发线程：等待进程指示的信号，并将其分配给 Java 级别的信号处理方法。

安全点：
1. 方法代码中被植入的安全点检测入口；
2. 线程处于安全点状态：线程暂停执行，这个时候线程栈不再发生改变；
3. JVM 的安全点状态：所有线程都处于安全点状态。

JVM 支持多种方式来进行线程转储：
1. JDK 工具, 包括: jstack 工具, jcmd 工具, jconsole, jvisualvm, Java Mission Control 等；
2. Shell 命令或者系统控制台, 比如 Linux 的 kill -3, Windows 的 Ctrl + Break 等；
3. JMX 技术， 主要是使用 ThreadMxBean。

> Java 内存分析与相关工具

`一个 Java 对象占用多少内存？`

可以使用 Instrumentation.getObjectSize() 方法来估算一个对象占用的内存空间。
JOL (Java Object Layout) 可以用来查看对象内存布局。

**对象头和对象引用**
在64位 JVM 中，对象头占据的空间是 12 byte(=96bit=64+32)，但是内存寻址空间以 8 字节对齐，所以一个空类的实例至少占用 16 字节。
在32位 JVM 中，对象头占 8 个字节，内存寻址空间以 4 的倍数对齐(32=4*8)。
所以 new 出来很多简单对象，甚至是 new Object()，都会占用不少内容。
通常在32位 JVM，以及内存小于 -Xmx32G 的64位JVM 上(默认开启指针压缩)，一个引用占的内存默认是4个字节。
因此，64位 JVM 一般需要多消耗堆内存。

**包装类型**
比原生数据类型消耗的内存要多，详情可以参考 JavaWorld :

Integer: 占用 16 字节(8 + 4 = 12 + 补齐)，因为 int 部分占4个字节。 所以使用 Integer 比原生类型 int 要多消耗 300% 的内存。

Long：一般占用16个字节(8+8=16)，当然，对象的实际大小由底层平台的内存对齐确定，具体由特定 CPU 平台的 JVM 实现决定。 看起来一个 Long 类型的对象，比起原生类型 long 多占用了8个字节（也多消耗了100%）。